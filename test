const AWS = require("aws-sdk");
const lambda = new AWS.Lambda();
const myDocumentClient = new AWS.DynamoDB.DocumentClient();

exports.handler = function(event, context, callback) {
    let role = null;
    let staffId = null;
    let channelId = null;
    let dateString = null;
    let ddbStaffMappingList = [];
    let temp = [];

    let startDate = event.queryStringParameters?.startDate || null;
    let endDate = event.queryStringParameters?.endDate || null;

    console.log("startDate: " + startDate);
    console.log("endDate: " + endDate);

    const paramsStaff = {
        FunctionName: "getStaffDetailsLMS",
        InvocationType: "RequestResponse",
        LogType: "Tail",
        Payload: JSON.stringify({
            queryStringParameters: {
                staffId: event.queryStringParameters?.staffId
            }
        })
    };

    lambda.invoke(paramsStaff, function (err, data) {
        if (err) {
            onError(err, callback);
        } else {
            try {
                const dataItems = JSON.parse(data.Payload);
                console.log("dataItems: ", dataItems);

                const resp = JSON.parse(dataItems.body);
                console.log("resp: ", resp);

                if (resp.response && resp.response.isExist === true) {
                    role = resp.response.role;
                    staffId = resp.response.stfrd;
                    channelId = resp.response.channelId;

                    const rangeDate = new Date(new Date().setDate(new Date().getDate()));
                    dateString = rangeDate.toISOString();

                    fetchAppByRole();
                } else {
                    const responseBody = {
                        respType: "e000",
                        response: "Agent does not exist. Please add agent before proceeding"
                    };
                    const responseFinal = setResponseFinal(responseBody);
                    callback(null, responseFinal);
                }
            } catch (parseErr) {
                onError(parseErr, callback);
            }
        }
    });

    function fetchAppByRole() {
        if (role === "TM") {
            queryStaffMappingTM();
        } else if (role === "TL") {
            queryStaffMappingTL();
        } else if (role === "CM") {
            queryStaffMappingCM();
        } else if (role === "PU") {
            scanStaffMappingPU();
        } else {
            const responseBody = {
                respType: "e000",
                response: "Role is not authorized to perform any action."
            };
            const responseFinal = setResponseFinal(responseBody);
            callback(null, responseFinal);
        }
    }

    function queryStaffMappingTM() {
        ddbStaffMappingList.push({ "STF_ID": staffId });
        const eventQueryAppDetails = setStaffMappingParams();
        callQueryAppDetailsLambda(eventQueryAppDetails);
    }

    function queryStaffMappingTL() {
        const getStaffList = {
            TableName: "STF_MAPPING",
            KeyConditionExpression: "#STF_ID = :stfId",
            ExpressionAttributeNames: { "#STF_ID": "STF_ID" },
            ExpressionAttributeValues: { ":stfId": staffId },
            ProjectionExpression: "STF_ID"
        };

        myDocumentClient.query(getStaffList, onQueryStaffMappingTL);
    }

    function onQueryStaffMappingTL(err, data) {
        if (err) {
            callback(err, null);
        } else {
            data.Items.forEach(function (itemData) {
                ddbStaffMappingList.push(itemData);
            });

            if (typeof data.LastEvaluatedKey !== "undefined") {
                const getStaffList = {
                    TableName: "STF_MAPPING",
                    ExclusiveStartKey: data.LastEvaluatedKey,
                    KeyConditionExpression: "#STF_ID = :stfId",
                    ExpressionAttributeNames: { "#STF_ID": "STF_ID" },
                    ExpressionAttributeValues: { ":stfId": staffId },
                    ProjectionExpression: "STF_ID"
                };
                myDocumentClient.query(getStaffList, onQueryStaffMappingTL);
            } else {
                queryStaffMappingTLForMgrId();
            }
        }
    }

    function queryStaffMappingTLForMgrId() {
        const getStaffList = {
            TableName: "STF_MAPPING",
            IndexName: "MGR_ID-index",
            KeyConditionExpression: "#MGR_ID = :stfId",
            ExpressionAttributeNames: { "#MGR_ID": "MGR_ID" },
            ExpressionAttributeValues: { ":stfId": staffId },
            ProjectionExpression: "STF_ID"
        };

        myDocumentClient.query(getStaffList, onQueryStaffMappingTLForMgrId);
    }

    function onQueryStaffMappingTLForMgrId(err, data) {
        if (err) {
            callback(err, null);
        } else {
            data.Items.forEach(function (itemData) {
                ddbStaffMappingList.push(itemData);
            });

            if (typeof data.LastEvaluatedKey !== "undefined") {
                const getStaffList = {
                    TableName: "STF_MAPPING",
                    IndexName: "MGR_ID-index",
                    ExclusiveStartKey: data.LastEvaluatedKey,
                    KeyConditionExpression: "#MGR_ID = :stfId",
                    ExpressionAttributeNames: { "#MGR_ID": "MGR_ID" },
                    ExpressionAttributeValues: { ":stfId": staffId },
                    ProjectionExpression: "STF_ID"
                };
                myDocumentClient.query(getStaffList, onQueryStaffMappingTLForMgrId);
            } else {
                const eventQueryAppDetails = setStaffMappingParams();
                callQueryAppDetailsLambda(eventQueryAppDetails);
            }
        }
    }

    function queryStaffMappingCM() {
        const getStaffList = {
            TableName: "STF_MAPPING",
            FilterExpression: "CHANNEL_ID = :channelId AND (#ROLE = :roleTM OR #ROLE = :roleTL)",
            ExpressionAttributeNames: { "#ROLE": "ROLE" },
            ExpressionAttributeValues: {
                ":channelId": channelId,
                ":roleTM": "TM",
                ":roleTL": "TL"
            },
            ProjectionExpression: "STF_ID,MGR_ID"
        };

        myDocumentClient.scan(getStaffList, onScanStaffMappingCM);
    }

    function onScanStaffMappingCM(err, data) {
        if (err) {
            callback(err, null);
        } else {
            data.Items.forEach(function (itemData) {
                ddbStaffMappingList.push(itemData);
            });

            if (typeof data.LastEvaluatedKey !== "undefined") {
                const getStaffList = {
                    TableName: "STF_MAPPING",
                    ExclusiveStartKey: data.LastEvaluatedKey,
                    FilterExpression: "CHANNEL_ID = :channelId AND (#ROLE = :roleTM OR #ROLE = :roleTL)",
                    ExpressionAttributeNames: { "#ROLE": "ROLE" },
                    ExpressionAttributeValues: {
                        ":channelId": channelId,
                        ":roleTM": "TM",
                        ":roleTL": "TL"
                    },
                    ProjectionExpression: "STF_ID,MGR_ID"
                };
                myDocumentClient.scan(getStaffList, onScanStaffMappingCM);
            } else {
                ddbStaffMappingList = ddbStaffMappingList.reduce((r, a) => {
                    const { MGR_ID, STF_ID } = a;
                    r[MGR_ID] = r[MGR_ID] || [];
                    r[MGR_ID].push({ STF_ID });
                    return r;
                }, {});
                const eventQueryAppDetails = setStaffMappingParams();
                callQueryAppDetailsLambda(eventQueryAppDetails);
            }
        }
    }

    function scanStaffMappingPU() {
        const getStaffList = {
            TableName: "CHNL_MAPPING",
            ProjectionExpression: "CHANNEL_ID"
        };

        myDocumentClient.scan(getStaffList, onScanStaffMappingPU);
    }

    function onScanStaffMappingPU(err, data) {
        if (err) {
            callback(err, null);
        } else {
            data.Items.forEach(function (itemData) {
                if (itemData.CHANNEL_ID && temp.indexOf(itemData.CHANNEL_ID) === -1) {
                    temp.push(itemData.CHANNEL_ID);
                }
                ddbStaffMappingList.push(itemData);
            });

            if (typeof data.LastEvaluatedKey !== "undefined") {
                const getStaffList = {
                    TableName: "CHNL_MAPPING",
                    ExclusiveStartKey: data.LastEvaluatedKey,
                    ProjectionExpression: "CHANNEL_ID"
                };
                myDocumentClient.scan(getStaffList, onScanStaffMappingPU);
            } else {
                const eventQueryAppDetails = setStaffMappingParams();
                callQueryAppDetailsLambda(eventQueryAppDetails);
            }
        }
    }

    function setStaffMappingParams() {
        return {
            ddbStaffMappingList,
            staffId,
            dateString,
            channelId,
            role,
            startDate,
            endDate
        };
    }

    function callQueryAppDetailsLambda(eventQueryAppDetails) {
        const tmParams = {
            FunctionName: "QueryAppDetailsLMSS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(eventQueryAppDetails)
        };

        lambda.invoke(tmParams, function (err, data) {
            if (err) {
                console.log("QueryAppDetailsLMS encountered error", err);
                onError(err, callback);
            } else {
                const responseBody = {
                    respType: "001",
                    response: "success",
                    role,
                    appData: JSON.parse(data.Payload)
                };
                const responseFinal = setResponseFinal(responseBody);
                callback(null, responseFinal);
            }
        });
    }

    function onError(err, callback) {
        const responseFail = {
            statusCode: 500,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Cache-Control",
                "Cache-Control": "no-cache, no-store, must-revalidate"
            },
            body: JSON.stringify(err),
            isBase64Encoded: false
        };
        callback(null, responseFail);
    }

    function setResponseFinal(responseBody) {
        return {
            statusCode: 200,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Cache-Control",
                "Cache-Control": "no-cache, no-store, must-revalidate"
            },
            body: JSON.stringify(responseBody),
            isBase64Encoded: false
        };
    }
}; 
