var AWS = require("aws-sdk");
var lambda = new AWS.Lambda();

exports.handler = function (event, context, callback) {

    var myDocumentClient = new AWS.DynamoDB.DocumentClient();

    var staffIdTableParams = null;
    var staffIdSearchKeyList = []; 
    var nonStaffIdTableParams = null;
    var nonStaffIdSearchKeyList = []; 
    var fullTableparams = null;
    var leadTableParams = null;
    var searchAppDetailsList = [];

    var role = event.role;
    var dateString = event.dateString;
    var searchKey = event.searchKey.toUpperCase();
    var channelId = event.channelid;
    var staffIndexList = event.ddbStaffMappingList; 
    var staffid = event.staffid;

    var responseBody = null;
    var responseFinal = null;
    var searchDict = {};

    if (role == "TM" || role === "TL" || role === "CM") {
        getStaffIdSearchKeyList();
        nonStaffIdSearch(0);
    } else if (role == "PU") {
        callback(null, "Role does not exist");
    } else {
        withChannelIdSearch(0);
    }

    function getStaffIdSearchKeyList() {
        staffIndexList.filter(function (x) {
            if (x.STF_ID.indexOf(searchKey) != -1) {
                staffIdSearchKeyList.push(x.STF_ID);
            } else {
                nonStaffIdSearchKeyList.push(x.STF_ID);
            }
        });
    }

    function withStaffIdSearch(index) {
        if (index == staffIdSearchKeyList.length) {
            callback(
                null,
                JSON.stringify(searchDict, function (key, value) {
                    if (value > Number.MAX_SAFE_INTEGER) {
                        return value.toString() + "";
                    } else {
                        return value;
                    }
                }),
            );
        } else {
            withStaffIdSearch_Util(index);
        }
    }

    function withStaffIdSearch_Util(index) {
        let STF_ID = staffIdSearchKeyList[index];
        staffIdTableParams = {
            TableName: "APP_DETAILS",
            IndexName: "STF_ID-CREATION_DT-index",
            KeyConditionExpression: "#STF_ID = :STF_ID AND #CREATION_DT >= :dateString",
            ExpressionAttributeNames: {
                "#STF_ID": "STF_ID",
                "#CREATION_DT": "CREATION_DT",
            },
            ExpressionAttributeValues: {
                ":dateString": dateString,
                ":STF_ID": STF_ID,
            },
        };

        try {
            searchAppDetailsList = [];
            myDocumentClient.query(staffIdTableParams, onQueryTable);

            function onQueryTable(err, data) {
                if (err) {
                    callback(err, null);
                } else {
                    let mapApp = null;
                    data.Items.forEach(function (itemData) {
                        mapApp = setAppData(itemData);
                        searchAppDetailsList.push(mapApp);
                    });

                    if (typeof data.LastEvaluatedKey != "undefined") {
                        staffIdTableParams.ExclusiveStartKey = data.LastEvaluatedKey;
                        myDocumentClient.query(staffIdTableParams, onQueryTable());
                    } else {
                        searchDict[STF_ID] = searchAppDetailsList;
                        withStaffIdSearch(index + 1);
                    }
                }
            }
        } catch (e) {
            console.log("error while querying data ----", e);
        }
    }

    function nonStaffIdSearch(index) {
        if (index == nonStaffIdSearchKeyList.length) {
            withStaffIdSearch(0);
        } else {
            nonStaffIdSearch_Util(index);
        }
    }

    function nonStaffIdSearch_Util(index) {
        let STF_ID = nonStaffIdSearchKeyList[index];
        nonStaffIdTableParams = {
            TableName: "APP_DETAILS",
            IndexName: "STF_ID-CREATION_DT-index",
            KeyConditionExpression: "#STF_ID = :STF_ID AND #CREATION_DT >= :dateString",
            FilterExpression: "contains (STF_NAME, :searchKey) OR contains (CUST_NAME, :searchKey) OR contains (CUST_MNAME, :searchKey) OR contains(CUST_LNAME, :searchKey) OR contains (ID_TYPE_VALUE, :searchKey) OR contains (MOB_NUM, :searchKey)",
            ExpressionAttributeNames: {
                "#STF_ID": "STF_ID",
                "#CREATION_DT": "CREATION_DT",
            },
            ExpressionAttributeValues: {
                ":STF_ID": STF_ID,
                ":searchKey": searchKey,
                ":dateString": dateString,
            },
        };

        try {
            searchAppDetailsList = [];
            myDocumentClient.query(nonStaffIdTableParams, onQuerySearchApps);

            function onQuerySearchApps(err, data) {
                if (err) {
                    callback(err, null);
                } else {
                    let mapApp = null;
                    data.Items.forEach(function (itemData) {
                        mapApp = setAppData(itemData);
                        searchAppDetailsList.push(mapApp);
                    });

                    if (typeof data.LastEvaluatedKey != "undefined") {
                        nonStaffIdTableParams.ExclusiveStartKey = data.LastEvaluatedKey;
                        myDocumentClient.query(nonStaffIdTableParams, onQuerySearchApps);
                    } else {
                        searchDict[STF_ID] = searchAppDetailsList;
                        nonStaffIdSearch(index + 1);
                    }
                }
            }
        } catch (e) {
            console.log("error while qerying data");
        }
    }

    function withChannelIdSearch(index) {
        if (index == staffIndexList.length) {
            callback(
                null,
                JSON.stringify(searchDict, function (key, value) {
                    if (value > Number.MAX_SAFE_INTEGER) {
                        return value.toString() + "";
                    } else {
                        return value;
                    }
                }),
            );
        } else {
            fullSearchAppDetails(index);
        }
    }

    function fullSearchAppDetails(index) {
        let channelId = staffIndexList[index].CHANNEL_ID;
        fullTableparams = {
            TableName: "APP_DETAILS",
            IndexName: "CHANNEL_ID-CREATION_DT-index",
            KeyConditionExpression: "CHANNEL_ID = :channelid AND CREATION_DT >= :dateString",
            FilterExpression: "contains (STF_ID, :searchKey) OR contains (STF_NAME, :searchKey) OR contains (CUST_NAME, :searchKey) OR contains(CUST_MNAME, :searchKey) OR contains (CUST_LNAME, :searchKey) OR contains (ID_TYPE_VALUE, :searchKey) OR contains (MOB_NUM, :searchKey)",
            ExpressionAttributeValues: {
                ":channelid": channelId,
                ":searchKey": searchKey,
                ":dateString": dateString,
            },
        };

        try {
            searchAppDetailsList = [];
            myDocumentClient.query(fullTableparams, fullScanSearchApps);

            function fullScanSearchApps(err, data) {
                if (err) {
                    callback(err, null);
                } else {
                    let mapApp = null;
                    data.Items.forEach(function (itemData) {
                        mapApp = setAppData(itemData);
                        searchAppDetailsList.push(mapApp);
                    });

                    if (typeof data.LastEvaluatedKey != "undefined") {
                        fullTableparams.ExclusiveStartKey = data.LastEvaluatedKey;
                        myDocumentClient.query(fullTableparams, fullScanSearchApps);
                    } else {
                        searchDict[channelId] = searchAppDetailsList;
                        withChannelIdSearch(index + 1);
                    }
                }
            }
        } catch (e) {
            console.log("error while gerving data");
        }
    }

    function setResponseFinal(responseBody) {
        let responseParam = {
            statusCode: 200,
            headers: {
                "Access-Control-Allow-Origin": "*",
            },
            body: JSON.stringify(responseBody),
            isBase64Encoded: false,
        };
        return responseParam;
    }

    function setAppData(items) {
        let mapParam = {};
        if (items != undefined) {
            mapParam = {
                appId: items.APP_ID,
                stafid: items.STF_ID,
                aapId: items.AAPS_ID,
                appStatus: items.AAPS_STATUS,
                additionalData: items.ADDITIONAL_DATA,
                applStatus: items.APPL_STATUS,
                bureauStatus: items.BUREAU_STATUS,
                campaignId: items.CAMPAIGN_ID,
                channelId: items.CHANNEL_ID,
                cifId: items.CIF,
                appCompletionDate: items.COMPLETION_DT,
                appCreationDate: items.CREATION_DT,
                custDob: items.CUST_DOB,
                custEmail: items.CUST_EMAIL,
                customerId: items.CUST_ID,
                custLname: items.CUST_LNAME,
                custMname: items.CUST_MNAME,
                homeCountry: items.HOME_COUNTRY,
                idType: items.ID_TYPE,
                isLead: items.IS_LEAD,
                mobileNumber: items.MOB_NUM,
                otpVerifyStatus: items.OTP_VERIFY_STATUS,
                remarks: items.REMARKS,
                srcUrl: items.SRC_URL,
                stfName: items.STF_NAME,
                homeBlock: items.HOME_BLOCK,
                homeCity: items.HOME_CITY,
                homeProvince: items.HOME_PROVINCE,
                homeStreet: items.HOME_STREET,
                homeZipcode: items.HOME_ZIPCODE,
                custSName: items.CUST_SNAME,
                omniCreditCardNo: items.OMNIO_CUST_REF,
                creditCardNum: items.CARD_NUMBER,
                message: items.APPMESSAGE,
                responseBody: items.APPResponseBody,
                appStatus: items.APPStatus,
                appIdNew: items.APP_ID,
                homeAdd1: items.HOME_ADD1,
                homeAdd2: items.HOME_ADD2,
                homeAdd3: items.HOME_ADD3,
                promoted: items.VOUCHER_CODE,
                idpValue: items.ID_TYPE_VALUE,
                staffTime: items.STAFFTIMESTAMP,
                followUpStatus: items.FOLLOWUPSTATUS,
                remarksNew: items.REMARKSNEW,
            };
        }
        return mapParam;
    }
};
