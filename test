import { LambdaClient, InvokeCommand } from "@aws-sdk/client-lambda";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, QueryCommand, ScanCommand } from "@aws-sdk/lib-dynamodb";

// Initialize AWS SDK v3 clients
const lambdaClient = new LambdaClient({});
const dynamoDBClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(dynamoDBClient);

export const handler = async (event, context) => {
    try {
        let role = null;
        let staffId = null;
        let channelId = null;
        let dateString = null;
        let ddbStaffMappingList = [];
        let temp = [];

        const startDate = event.queryStringParameters?.startDate || null;
        const endDate = event.queryStringParameters?.endDate || null;

        console.log("startDate:", startDate);
        console.log("endDate:", endDate);

        // Get staff details
        const staffDetails = await getStaffDetails(event.queryStringParameters?.staffId);
        
        if (!staffDetails.response || !staffDetails.response.isExist) {
            return createResponse({
                respType: "e000",
                response: "Agent does not exist. Please add agent before proceeding"
            });
        }

        role = staffDetails.response.role;
        staffId = staffDetails.response.stfrd;
        channelId = staffDetails.response.channelId;

        const rangeDate = new Date();
        dateString = rangeDate.toISOString();

        // Fetch applications by role
        ddbStaffMappingList = await fetchAppByRole(role, staffId, channelId, temp);

        // Call QueryAppDetailsLMSS Lambda
        const eventQueryAppDetails = {
            ddbStaffMappingList,
            staffId,
            dateString,
            channelId,
            role,
            startDate,
            endDate
        };

        const appData = await callQueryAppDetailsLambda(eventQueryAppDetails);

        return createResponse({
            respType: "001",
            response: "success",
            role,
            appData
        });

    } catch (error) {
        console.error("Lambda execution error:", error);
        return createErrorResponse(error);
    }
};

// Get staff details from another Lambda function
const getStaffDetails = async (staffId) => {
    const params = {
        FunctionName: "getStaffDetailsLMS",
        InvocationType: "RequestResponse",
        LogType: "Tail",
        Payload: JSON.stringify({
            queryStringParameters: { staffId }
        })
    };

    try {
        const command = new InvokeCommand(params);
        const data = await lambdaClient.send(command);
        
        const dataItems = JSON.parse(new TextDecoder().decode(data.Payload));
        console.log("dataItems:", dataItems);
        
        const resp = JSON.parse(dataItems.body);
        console.log("resp:", resp);
        
        return resp;
    } catch (error) {
        console.error("Error getting staff details:", error);
        throw error;
    }
};

// Main function to fetch applications based on role
const fetchAppByRole = async (role, staffId, channelId, temp) => {
    switch (role) {
        case "TM":
            return [{ "STF_ID": staffId }];
        case "TL":
            return await queryStaffMappingTL(staffId);
        case "CM":
            return await queryStaffMappingCM(channelId);
        case "PU":
            return await scanStaffMappingPU(temp);
        default:
            throw new Error("Role is not authorized to perform any action.");
    }
};

// Query staff mapping for Team Leader role
const queryStaffMappingTL = async (staffId) => {
    const staffList = [];
    
    // Query primary staff mapping
    const primaryStaff = await queryWithPagination({
        TableName: "STF_MAPPING",
        KeyConditionExpression: "#STF_ID = :stfId",
        ExpressionAttributeNames: { "#STF_ID": "STF_ID" },
        ExpressionAttributeValues: { ":stfId": staffId },
        ProjectionExpression: "STF_ID"
    });
    
    staffList.push(...primaryStaff);
    
    // Query staff mapping by manager ID
    const managedStaff = await queryWithPagination({
        TableName: "STF_MAPPING",
        IndexName: "MGR_ID-index",
        KeyConditionExpression: "#MGR_ID = :stfId",
        ExpressionAttributeNames: { "#MGR_ID": "MGR_ID" },
        ExpressionAttributeValues: { ":stfId": staffId },
        ProjectionExpression: "STF_ID"
    });
    
    staffList.push(...managedStaff);
    
    return staffList;
};

// Query staff mapping for Channel Manager role
const queryStaffMappingCM = async (channelId) => {
    const staffList = await scanWithPagination({
        TableName: "STF_MAPPING",
        FilterExpression: "CHANNEL_ID = :channelId AND (#ROLE = :roleTM OR #ROLE = :roleTL)",
        ExpressionAttributeNames: { "#ROLE": "ROLE" },
        ExpressionAttributeValues: {
            ":channelId": channelId,
            ":roleTM": "TM",
            ":roleTL": "TL"
        },
        ProjectionExpression: "STF_ID,MGR_ID"
    });

    // Group staff by manager ID
    return staffList.reduce((acc, item) => {
        const { MGR_ID, STF_ID } = item;
        acc[MGR_ID] = acc[MGR_ID] || [];
        acc[MGR_ID].push({ STF_ID });
        return acc;
    }, {});
};

// Scan staff mapping for Power User role
const scanStaffMappingPU = async (temp) => {
    const channelList = await scanWithPagination({
        TableName: "CHNL_MAPPING",
        ProjectionExpression: "CHANNEL_ID"
    });

    // Filter unique channel IDs
    channelList.forEach(item => {
        if (item.CHANNEL_ID && !temp.includes(item.CHANNEL_ID)) {
            temp.push(item.CHANNEL_ID);
        }
    });

    return channelList;
};

// Generic function for DynamoDB Query with pagination
const queryWithPagination = async (params) => {
    const items = [];
    let lastEvaluatedKey = null;

    do {
        const queryParams = { ...params };
        if (lastEvaluatedKey) {
            queryParams.ExclusiveStartKey = lastEvaluatedKey;
        }

        try {
            const command = new QueryCommand(queryParams);
            const data = await docClient.send(command);
            
            items.push(...data.Items);
            lastEvaluatedKey = data.LastEvaluatedKey;
        } catch (error) {
            console.error("Error in queryWithPagination:", error);
            throw error;
        }
    } while (lastEvaluatedKey);

    return items;
};

// Generic function for DynamoDB Scan with pagination
const scanWithPagination = async (params) => {
    const items = [];
    let lastEvaluatedKey = null;

    do {
        const scanParams = { ...params };
        if (lastEvaluatedKey) {
            scanParams.ExclusiveStartKey = lastEvaluatedKey;
        }

        try {
            const command = new ScanCommand(scanParams);
            const data = await docClient.send(command);
            
            items.push(...data.Items);
            lastEvaluatedKey = data.LastEvaluatedKey;
        } catch (error) {
            console.error("Error in scanWithPagination:", error);
            throw error;
        }
    } while (lastEvaluatedKey);

    return items;
};

// Call another Lambda function
const callQueryAppDetailsLambda = async (eventQueryAppDetails) => {
    const params = {
        FunctionName: "QueryAppDetailsLMSS",
        InvocationType: "RequestResponse",
        LogType: "Tail",
        Payload: JSON.stringify(eventQueryAppDetails)
    };

    try {
        const command = new InvokeCommand(params);
        const data = await lambdaClient.send(command);
        
        return JSON.parse(new TextDecoder().decode(data.Payload));
    } catch (error) {
        console.error("QueryAppDetailsLMS encountered error:", error);
        throw error;
    }
};

// Create successful response
const createResponse = (responseBody, statusCode = 200) => ({
    statusCode,
    headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "Cache-Control",
        "Cache-Control": "no-cache, no-store, must-revalidate"
    },
    body: JSON.stringify(responseBody),
    isBase64Encoded: false
});

// Create error response
const createErrorResponse = (error, statusCode = 500) => ({
    statusCode,
    headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "Cache-Control",
        "Cache-Control": "no-cache, no-store, must-revalidate"
    },
    body: JSON.stringify({
        error: error.message || "Internal server error",
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    }),
    isBase64Encoded: false
});
