const { S3Client, ListObjectsCommand, GetObjectCommand } = require("@aws-sdk/client-s3");
const { getSignedUrl } = require("@aws-sdk/s3-request-presigner"); // Might be useful for direct image links

// Initialize S3 Client for SDK v3
const s3Client = new S3Client({ region: process.env.AWS_REGION || "eu-west-1" });
const BUCKET_NAME = "rocketmnlacustomerdocumentsbucket"; // Define bucket name

module.exports = {
  getDocumentRecords: async function (appId) { // Changed to async function
    const files = [];
    const additionalFiles = [];
    let imgCust = null; // Use null for no image, not empty string
    const jumioDocs = [];

    const vparams = {
      Bucket: BUCKET_NAME,
      Prefix: `${appId}/` // Assuming documents are organized by appId as a prefix
    };

    try {
      const data = await s3Client.send(new ListObjectsCommand(vparams)); // Use SDK v3 ListObjectsCommand
      const promises = [];

      if (data.Contents) {
        for (const doc of data.Contents) {
          if (doc.Key) { // Ensure doc.Key exists
            promises.push(processFileObject(doc.Key));
          }
        }
      }

      const processedObjects = await Promise.all(promises);

      for (const obj of processedObjects) {
        if (!obj || !obj.docType) continue; // Skip if object is null or missing docType

        // Filter based on docType derived from the key
        switch (obj.docType) {
          case "PrimaryDocument":
            files.push(obj);
            break;
          case "AdditionalDocument":
            additionalFiles.push(obj);
            break;
          case "SuppCustomerSignature":
            imgCust = obj;
            break;
          case "JumioDocument":
            if (obj.imagePreviewUrl && obj.imagePreviewUrl.includes("jpeg")) {
              jumioDocs.push(obj);
            }
            break;
        }
      }

      console.log("fileObject jumioDocs length in s3 bucket: ", jumioDocs.length);
      // Return an object that matches the expected structure in index.js for pdfRequestData
      return {
        files: files,
        additionalFiles: additionalFiles,
        imgCust: imgCust,
        jumioDocs: jumioDocs,
      };

    } catch (err) {
      console.error("Error listing S3 objects:", err);
      throw err; // Re-throw the error for upstream handling
    }
  },
};

const processFileObject = async (key) => {
  const getObjparams = {
    Bucket: BUCKET_NAME,
    Key: key,
  };
  let obj = {};

  try {
    const data = await s3Client.send(new GetObjectCommand(getObjparams)); // Use SDK v3 GetObjectCommand
    console.log("key is " + key);

    const keyArr = key.split("/");
    const docType = keyArr[1]; // Assuming docType is the second part of the key
    let fileName = keyArr[2]; // Default filename
    if (keyArr.length === 4) {
      fileName = keyArr[3]; // If a fourth part exists, use it as filename
    }

    // Read the stream and convert to base64
    const imagePreviewUrl = await new Promise((resolve, reject) => {
      const chunks = [];
      data.Body.on('data', (chunk) => chunks.push(chunk));
      data.Body.once('end', () => resolve(`data:${data.ContentType};base64,${Buffer.concat(chunks).toString('base64')}`));
      data.Body.once('error', reject);
    });

    obj = {
      docType: docType, // Added docType to the object for easier filtering
      fileName: fileName,
      docName: docType, // Using docType as docName for now, adjust if actual docName is different
      imagePreviewUrl: imagePreviewUrl,
      file: {}, // Placeholder, adjust if actual file content is needed differently
    };

    return obj;
  } catch (err) {
    console.error(`Error getting S3 object ${key}:`, err);
    return null; // Return null or throw a more specific error
  }
};
