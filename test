var AWS = require("aws-sdk"); 

var lambda = new AWS.Lambda(); 
var myDocumentClient = new AWS.DynamoDB.DocumentClient(); 

exports.handler = function (event, context, callback) { 
    var role = null;
    var staffId = null; 
    var channelId = null; 
    var rangeDate = null; 
    var dateString = null; 
    var ddbStaffMappingList = [ ]; 
    var temp = [ ]; 
    var getStaffList = null; 
    var eventQueryAppDetails = null; 

    //final response format
    var responseBody = null; 
    var responseFinal = null; 

    //check if staff exists
    var paramsStaff = { 
        FunctionName: "getStaffDetailsLMS", // the lambda function we are going to invoke
        InvocationType: "RequestResponse", 
        LogType: "Tail", 
        Payload: "" ,
    }; 

    
    paramsStaff.Payload = JSON.stringify(event.queryStringParameters.staffId, null, 2); 
    
    var startDate = ""; 
    var endDate = ""; 

    startDate = event.queryStringParameters.startDate; 
    endDate = event.queryStringParameters.endDate; 

    console.log("startDate:", startDate); 
    console.log("endDate:", endDate); 

    lambda.invoke(paramsStaff, function (err, data) { 
        console.log("paramsStaff:", paramsStaff); 
        if (err) { 
            onError(err, callback); 
        } else { 
            var dataItems = JSON.parse(data.Payload); 
            console.log("dataItems:", dataItems); 
            
            var resp = JSON.parse(dataItems.body); 
            console.log(":", resp); 
            if (
(resp.response !== null && resp.response !== undefined) && // Corrected logical OR to AND
                 resp.response.isExist === true) { 
                    role = resp.response.role; 
                    staffId = resp.response.stfId; 
                    channelId = resp.response.channelId; 
                    rangeDate = new Date(new Date().setDate(new Date().getDate() - 60)); 
                    dateString = rangeDate.toISOString(); 
                    fetchAppByRole(); 
                } else { 
                    responseBody = { 
                        respType: "000", 
                        response: "Agent does not exist. Please check agent before proceeding" 
                    }; 
                    responseFinal = setResponseFinal(responseBody); 
                    callback(null, responseFinal); 
                
            }
        }
    });

    function fetchAppByRole() { 
        if (role === "TM") { 
            queryStaffMappingTM(); 
        } else if (role === "TL") { 
            queryStaffMappingTL(); 
        } else if (role === "CM") { 
            queryStaffMappingCM(); 
        } else if (role === "PU") { 
            scanStaffMappingPU(); 
        } else { 
            responseBody = { 
                respType: "000", 
                response: "Role is not authorized to perform any action." 
            }; 
            responseFinal = setResponseFinal(responseBody); 
            callback(null, responseFinal); 
        }
    }

    function queryStaffMappingTM() { 
        ddbStaffMappingList = [ { STF_ID: staffId, }]; 
        eventQueryAppDetails = setStaffMappingParams(); 
        
        callQueryAppDetailsLambda(eventQueryAppDetails); 
    }

    //for TL to fetch self & TM's staff id
    function queryStaffMappingTL() { 
        console.log("Inside queryStaffMappingTL executing: "); 
        let getStaffList = { 
            TableName: "STF_MAPPING", 
            KeyConditionExpression: "#STF_ID = :stfId", 
            ExpressionAttributeNames: { 
                "#STF_ID": "STF_ID", 
            }, 
            ExpressionAttributeValues: { 
                ":stfId": staffId, 
            }, 
            ProjectionExpression: "STF_ID", 
        }; 
        myDocumentClient.query(getStaffList, onQueryStaffmappingTL); 
    }

    function onQueryStaffmappingTL(err, data) { 
        console.log("Inside onQueryStaffmappingTL executing: "); 
        if (err) { 
            callback(err, null); 
        } else { 
            data.Items.forEach(function (itemData) { 
                ddbStaffMappingList.push(itemData); 
            }); 
            if (typeof data.LastEvaluatedKey != "undefined") { 
                getStaffList.ExclusiveStartKey = data.LastEvaluatedKey; 
                myDocumentClient.query(getStaffList, onQueryStaffmappingTL); 
            } else { 
                eventQueryAppDetails = setStaffMappingParams(); // This line was moved up from inside queryStaffMappingTLForMgrId()
                queryStaffMappingTLForMgrId(); 
            }
        }
    }

    function queryStaffMappingTLForMgrId() { 
        let getStaffList = { 
            TableName: "STF_MAPPING", 
            IndexName: "MGR_ID-index", // Removed '#' from '#MGR_ID-index'
            KeyConditionExpression: "MGR_ID = :stfId", 
            ExpressionAttributeNames: { 
                "#MGR_ID": "MGR_ID", 
            }, 
            ExpressionAttributeValues: { 
                ":stfId": staffId, 
            }, 
            ProjectionExpression: "STF_ID", 
        }; 
        myDocumentClient.query(getStaffList, onQueryStaffMappingTLForMgrId); 
    }

    function onQueryStaffMappingTLForMgrId(err, data) { 
        if (err) { 
            callback(err, null); 
        } else { 
            data.Items.forEach(function (itemData) { 
                ddbStaffMappingList.push(itemData); 
            }); 
            if (typeof data.LastEvaluatedKey != "undefined") { 
                getStaffList.ExclusiveStartKey = data.LastEvaluatedKey; 
                myDocumentClient.query(getStaffList, onQueryStaffMappingTLForMgrId); 
            } else { 
                eventQueryAppDetails = setStaffMappingParams(); 
                // callback(null, eventQueryAppDetails); 
                console.log("eventQueryAppDetails:", eventQueryAppDetails); 
                callQueryAppDetailsLambda(eventQueryAppDetails); 
            }
        }
    }

    //for CM
    function queryStaffMappingCM(callback) { 
        getStaffList = { 
            TableName: "STF_MAPPING", 
            FilterExpression: "CHANNEL_ID = :channelId AND (#STAFF_ROLE = :roleTM OR #STAFF_ROLE = :roleTL)", 
            ExpressionAttributeNames: { 
                "#STAFF_ROLE": "ROLE", 
            }, 
            ExpressionAttributeValues: { 
                ":channelId": channelId, 
                ":roleTM": "TM", 
                ":roleTL": "TL", 
            }, 
            ProjectionExpression: "STF_ID, MGR_ID", 
        }; 
        myDocumentClient.scan(getStaffList, onScanStaffmappingCM); 
    }

    function onScanStaffmappingCM(err, data) { 
        if (err) { 
            callback(err, null); 
        } else { 
            data.Items.forEach(function (itemData) { 
                ddbStaffMappingList.push(itemData); 
            }); 
            if (typeof data.LastEvaluatedKey != "undefined") { 
                getStaffList.ExclusiveStartKey = data.LastEvaluatedKey; 
                myDocumentClient.scan(getStaffList, onScanStaffmappingCM); 
            } else { 
                ddbStaffMappingList = ddbStaffMappingList.reduce((r, a) => { 
                    const {
                        MGR_ID,
                        STF_ID
                    } = a; 
                    r[MGR_ID] = [ ...(r[MGR_ID] || []), { STF_ID}]; // Corrected spread operator usage
                    
                    return r; 
                }, {}); 
                eventQueryAppDetails = setStaffMappingParams(); 
                // callback(null, eventQueryAppDetails); 
                callQueryAppDetailsLambda(eventQueryAppDetails); 
            }
        }
    }

    //for PU
    function scanStaffMappingPU(callback) { 
        getStaffList = { 
            TableName: "CHNL_MAPPING", 
            ProjectionExpression: "CHANNEL_ID", 
        }; 
        myDocumentClient.scan(getStaffList, onScanStaffmapping); 
    }

    function onScanStaffmapping(err, data) { 
        if (err) { 
            callback(err, null); 
        } else { 
            data.Items.forEach(function (itemData) { 
                if (itemData.CHANNEL_ID !== undefined && itemData.CHANNEL_ID !== "") { // Changed || to &&
                    if (temp.indexOf(itemData.CHANNEL_ID) === -1) { 
                        temp.push(itemData.CHANNEL_ID); 
                    } // Closing brace added here
                    ddbStaffMappingList.push(itemData); 
                } 
            }); 
            if (typeof data.LastEvaluatedKey !== "undefined") { 
                getStaffList.ExclusiveStartKey = data.LastEvaluatedKey; 
                myDocumentClient.scan(getStaffList, onScanStaffmapping); 
            } else { 
                eventQueryAppDetails = setStaffMappingParams(); 
                // callback(null, eventQueryAppDetails); 
                callQueryAppDetailsLambda(eventQueryAppDetails); 
            }
        }
    }

    //set eventQueryAppDetails value as according to QueryAppDetails Lambda
    function setStaffMappingParams() { 
        var eventQueryAppDetails = { 
            ddbStaffMappingList: ddbStaffMappingList, 
            staffId: staffId, 
            dateString: dateString, 
            channelId: channelId, 
            role: role, 
            startDate: startDate, 
            endDate: endDate, 
        }; 
        return eventQueryAppDetails; 
    }

    //common function for tm and sl to fetch customer details
    function callQueryAppDetailsLambda(eventQueryAppDetails) { 
        console.log("inside callQueryAppDetailstambda"); 
        var tmParams = { 
            FunctionName: "QueryAppDetailsLMS", 
            InvocationType: "RequestResponse", 
            LogType: "Tail", 
            Payload: "" ,
        }; 
        console.log("eventQueryAppDetails:", eventQueryAppDetails); 
        tmParams.Payload = JSON.stringify(eventQueryAppDetails, null, 2); 
        lambda.invoke(tmParams, function (err, data) { 
            if (err) { 
                console.log("QueryAppDetailsLMS encountered error", err); 
                onError(err, callback); 
            } else { 
                console.log("QueryAppDetailsLMS no error observed"); 
                responseBody = { 
                    respType: "001", 
                    response: "Success", 
                    role: role, 
                    appData: JSON.parse(data.Payload), 
                }; 
                responseFinal = setResponseFinal(responseBody); 
                callback(null, responseFinal); 
            }
        }); 
    }

    //common function for errors
    function onError(err, callback) { 
        var responseFail = { 
            statusCode: 500, 
            headers: { 
                "Access-Control-Allow-Origin": "*", 
                "Access-Control-Allow-Headers": "Cache-Control", 
                "Cache-Control": "no-cache, no-store, must-revalidate", 
            }, 
            body: err, 
            isBase64Encoded: false, 
        }; 
        // callback(err, null); 
        callback(null, responseFail); 
    }

    function setResponseFinal(responseBody) { 
        console.log("inside setResponseFinal"); 
        let responseParam = { 
            statusCode: 200, 
            headers: { 
                "Access-Control-Allow-Origin": "*", 
                "Access-Control-Allow-Headers": "Cache-Control", 
                "Cache-Control": "no-cache, no-store, must-revalidate", 
            }, 
            body: JSON.stringify(responseBody), 
            isBase64Encoded: false, 
        }; 
        return responseParam; 
    }
};
