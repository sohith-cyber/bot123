import { LambdaClient, InvokeCommand } from "@aws-sdk/client-lambda";
import { DynamoDBDocumentClient, QueryCommand, ScanCommand } from "@aws-sdk/lib-dynamodb";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

const lambda = new LambdaClient({});
const dynamoDbClient = new DynamoDBClient({});
const myDocumentClient = DynamoDBDocumentClient.from(dynamoDbClient);

export const handler = async (event) => {
    let role = null;
    let staffId = null;
    let channelId = null;
    let rangeDate = null;
    let dateString = null;
    let ddbStaffMappingList = [];
    let tempChannelIds = []; // Renamed 'temp' to be more descriptive
    let getStaffListParams = null; // Renamed to avoid confusion with the function

    // final response format
    let responseBody = null;

    const startDate = event.queryStringParameters.startDate;
    const endDate = event.queryStringParameters.endDate;

    console.log("startDate:", startDate);
    console.log("endDate:", endDate);

    try {
        // Check if staff exists
        const paramsStaff = {
            FunctionName: "getStaffDetailsLMS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(event.queryStringParameters.staffId),
        };

        console.log("paramsStaff:", paramsStaff);
        const lambdaInvokeResponse = await lambda.send(new InvokeCommand(paramsStaff));
        const dataItems = JSON.parse(Buffer.from(lambdaInvokeResponse.Payload).toString()); // SDK v3 returns Payload as Uint8Array
        console.log("dataItems:", dataItems);

        const resp = JSON.parse(dataItems.body);
        console.log("Response from getStaffDetailsLMS:", resp);

        if (resp.response && resp.response.isExist === true) {
            role = resp.response.role;
            staffId = resp.response.stfId;
            channelId = resp.response.channelId;
            rangeDate = new Date(new Date().setDate(new Date().getDate() - 60));
            dateString = rangeDate.toISOString();

            await fetchAppByRole(); // Await the async function
        } else {
            responseBody = {
                respType: "000",
                response: "Agent does not exist. Please check agent before proceeding"
            };
            return setResponseFinal(responseBody);
        }
    } catch (err) {
        console.error("Error in main handler:", err);
        return onError(err);
    }

    async function fetchAppByRole() {
        if (role === "TM") {
            ddbStaffMappingList = [{ STF_ID: staffId }];
            const eventQueryAppDetails = setStaffMappingParams();
            await callQueryAppDetailsLambda(eventQueryAppDetails);
        } else if (role === "TL") {
            await queryStaffMappingTL();
        } else if (role === "CM") {
            await queryStaffMappingCM();
        } else if (role === "PU") {
            await scanStaffMappingPU();
        } else {
            responseBody = {
                respType: "000",
                response: "Role is not authorized to perform any action."
            };
            return setResponseFinal(responseBody);
        }
    }

    async function queryStaffMappingTL() {
        console.log("Inside queryStaffMappingTL executing:");
        getStaffListParams = {
            TableName: "STF_MAPPING",
            KeyConditionExpression: "#STF_ID = :stfId",
            ExpressionAttributeNames: {
                "#STF_ID": "STF_ID",
            },
            ExpressionAttributeValues: {
                ":stfId": staffId,
            },
            ProjectionExpression: "STF_ID",
        };

        await onQueryStaffmappingTL(); // Start the recursive query
    }

    async function onQueryStaffmappingTL() {
        console.log("Inside onQueryStaffmappingTL executing:");
        const data = await myDocumentClient.send(new QueryCommand(getStaffListParams));

        data.Items.forEach((itemData) => {
            ddbStaffMappingList.push(itemData);
        });

        if (data.LastEvaluatedKey) {
            getStaffListParams.ExclusiveStartKey = data.LastEvaluatedKey;
            await onQueryStaffmappingTL(); // Continue querying
        } else {
            await queryStaffMappingTLForMgrId();
        }
    }

    async function queryStaffMappingTLForMgrId() {
        const queryParams = {
            TableName: "STF_MAPPING",
            IndexName: "MGR_ID-index", // IndexName does not use '#'
            KeyConditionExpression: "MGR_ID = :stfId",
            ExpressionAttributeValues: {
                ":stfId": staffId,
            },
            ProjectionExpression: "STF_ID",
        };

        let lastEvaluatedKey;
        do {
            if (lastEvaluatedKey) {
                queryParams.ExclusiveStartKey = lastEvaluatedKey;
            }
            const data = await myDocumentClient.send(new QueryCommand(queryParams));
            data.Items.forEach((itemData) => {
                ddbStaffMappingList.push(itemData);
            });
            lastEvaluatedKey = data.LastEvaluatedKey;
        } while (lastEvaluatedKey);

        const eventQueryAppDetails = setStaffMappingParams();
        console.log("eventQueryAppDetails:", eventQueryAppDetails);
        await callQueryAppDetailsLambda(eventQueryAppDetails);
    }

    // for CM
    async function queryStaffMappingCM() {
        getStaffListParams = {
            TableName: "STF_MAPPING",
            FilterExpression: "CHANNEL_ID = :channelId AND (#STAFF_ROLE = :roleTM OR #STAFF_ROLE = :roleTL)",
            ExpressionAttributeNames: {
                "#STAFF_ROLE": "ROLE",
            },
            ExpressionAttributeValues: {
                ":channelId": channelId,
                ":roleTM": "TM",
                ":roleTL": "TL",
            },
            ProjectionExpression: "STF_ID, MGR_ID",
        };

        await onScanStaffmappingCM();
    }

    async function onScanStaffmappingCM() {
        const data = await myDocumentClient.send(new ScanCommand(getStaffListParams));

        data.Items.forEach((itemData) => {
            ddbStaffMappingList.push(itemData);
        });

        if (data.LastEvaluatedKey) {
            getStaffListParams.ExclusiveStartKey = data.LastEvaluatedKey;
            await onScanStaffmappingCM();
        } else {
            // This part transforms the ddbStaffMappingList. Ensure this is the desired final structure.
            ddbStaffMappingList = ddbStaffMappingList.reduce((r, a) => {
                const { MGR_ID, STF_ID } = a;
                // Assuming you want to group STF_ID by MGR_ID
                if (!r[MGR_ID]) {
                    r[MGR_ID] = [];
                }
                r[MGR_ID].push({ STF_ID });
                return r;
            }, {});

            const eventQueryAppDetails = setStaffMappingParams();
            await callQueryAppDetailsLambda(eventQueryAppDetails);
        }
    }

    // for PU
    async function scanStaffMappingPU() {
        getStaffListParams = {
            TableName: "CHNL_MAPPING",
            ProjectionExpression: "CHANNEL_ID",
        };

        await onScanStaffmapping();
    }

    async function onScanStaffmapping() {
        const data = await myDocumentClient.send(new ScanCommand(getStaffListParams));

        data.Items.forEach((itemData) => {
            if (itemData.CHANNEL_ID !== undefined && itemData.CHANNEL_ID !== "") { // Changed || to &&
                if (tempChannelIds.indexOf(itemData.CHANNEL_ID) === -1) {
                    tempChannelIds.push(itemData.CHANNEL_ID);
                    ddbStaffMappingList.push(itemData); // Pushing the whole item, but tempChannelIds is for unique check
                }
            }
        });

        if (data.LastEvaluatedKey) {
            getStaffListParams.ExclusiveStartKey = data.LastEvaluatedKey;
            await onScanStaffmapping();
        } else {
            const eventQueryAppDetails = setStaffMappingParams();
            await callQueryAppDetailsLambda(eventQueryAppDetails);
        }
    }

    // set eventQueryAppDetails value as according to QueryAppDetails Lambda
    function setStaffMappingParams() {
        return {
            ddbStaffMappingList: ddbStaffMappingList,
            staffId: staffId,
            dateString: dateString,
            channelId: channelId,
            role: role,
            startDate: startDate,
            endDate: endDate,
        };
    }

    // common function for tm and sl to fetch customer details
    async function callQueryAppDetailsLambda(eventQueryAppDetails) {
        console.log("inside callQueryAppDetailstambda");
        const tmParams = {
            FunctionName: "QueryAppDetailsLMS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(eventQueryAppDetails),
        };

        console.log("eventQueryAppDetails for QueryAppDetailsLMS:", eventQueryAppDetails);
        try {
            const data = await lambda.send(new InvokeCommand(tmParams));
            console.log("QueryAppDetailsLMS no error observed");
            responseBody = {
                respType: "001",
                response: "Success",
                role: role,
                appData: JSON.parse(Buffer.from(data.Payload).toString()),
            };
            return setResponseFinal(responseBody);
        } catch (err) {
            console.error("QueryAppDetailsLMS encountered error", err);
            return onError(err);
        }
    }

    // common function for errors
    function onError(err) {
        console.error("Error encountered:", err);
        const responseFail = {
            statusCode: 500,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Cache-Control",
                "Cache-Control": "no-cache, no-store, must-revalidate",
            },
            body: JSON.stringify({ message: "Internal Server Error", error: err.message }), // More descriptive error
            isBase64Encoded: false,
        };
        return responseFail;
    }

    function setResponseFinal(responseBody) {
        console.log("inside setResponseFinal");
        const responseParam = {
            statusCode: 200,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Cache-Control",
                "Cache-Control": "no-cache, no-store, must-revalidate",
            },
            body: JSON.stringify(responseBody),
            isBase64Encoded: false,
        };
        return responseParam;
    }
};
