import { LambdaClient, InvokeCommand } from "@aws-sdk/client-lambda";
import { DynamoDBDocumentClient, QueryCommand, ScanCommand } from "@aws-sdk/lib-dynamodb";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

const lambda = new LambdaClient({});
const dynamoDbClient = new DynamoDBClient({});
const myDocumentClient = DynamoDBDocumentClient.from(dynamoDbClient);

export const handler = async (event) => {
    let role = null;
    let staffId = null;
    let channelId = null;
    let rangeDate = null;
    let dateString = null;
    let ddbStaffMappingList = [];
    let tempChannelIds = [];
    let getStaffListParams = null; // Defined here for broader scope if needed, though often redefined locally.

    const startDate = event.queryStringParameters.startDate;
    const endDate = event.queryStringParameters.endDate;

    console.log("startDate:", startDate);
    console.log("endDate:", endDate);

    try {
        // Check if staff exists
        const paramsStaff = {
            FunctionName: "getStaffDetailsLMS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(event.queryStringParameters.staffId),
        };

        console.log("paramsStaff:", paramsStaff);
        const lambdaInvokeResponse = await lambda.send(new InvokeCommand(paramsStaff));
        const dataItems = JSON.parse(Buffer.from(lambdaInvokeResponse.Payload).toString());
        console.log("dataItems:", dataItems);

        const resp = JSON.parse(dataItems.body);
        console.log("Response from getStaffDetailsLMS:", resp);

        if (resp.response && resp.response.isExist === true) {
            role = resp.response.role;
            staffId = resp.response.stfId;
            channelId = resp.response.channelId;
            rangeDate = new Date(new Date().setDate(new Date().getDate() - 60));
            dateString = rangeDate.toISOString();

            // Await the result of fetchAppByRole and return it directly
            return await fetchAppByRole();
        } else {
            const responseBody = {
                respType: "000",
                response: "Agent does not exist. Please check agent before proceeding"
            };
            return setResponseFinal(responseBody);
        }
    } catch (err) {
        console.error("Error in main handler:", err);
        return onError(err);
    }

    // --- Helper Functions (nested or defined outside handler for clarity) ---

    async function fetchAppByRole() {
        // All paths in fetchAppByRole must eventually return the final response
        if (role === "TM") {
            ddbStaffMappingList = [{ STF_ID: staffId }];
            const eventQueryAppDetails = setStaffMappingParams();
            return await callQueryAppDetailsLambda(eventQueryAppDetails); // Return here
        } else if (role === "TL") {
            // The TL path will eventually call callQueryAppDetailsLambda, which returns the response
            return await queryStaffMappingTL();
        } else if (role === "CM") {
            return await queryStaffMappingCM();
        } else if (role === "PU") {
            return await scanStaffMappingPU();
        } else {
            const responseBody = {
                respType: "000",
                response: "Role is not authorized to perform any action."
            };
            return setResponseFinal(responseBody);
        }
    }

    async function queryStaffMappingTL() {
        console.log("Inside queryStaffMappingTL executing:");
        getStaffListParams = { // Re-assign within scope
            TableName: "STF_MAPPING",
            KeyConditionExpression: "#STF_ID = :stfId",
            ExpressionAttributeNames: {
                "#STF_ID": "STF_ID",
            },
            ExpressionAttributeValues: {
                ":stfId": staffId,
            },
            ProjectionExpression: "STF_ID",
        };

        await onQueryStaffmappingTL(); // This populates ddbStaffMappingList
        return await queryStaffMappingTLForMgrId(); // Ensure the final result is returned
    }

    async function onQueryStaffmappingTL() {
        console.log("Inside onQueryStaffmappingTL executing:");
        const data = await myDocumentClient.send(new QueryCommand(getStaffListParams));

        data.Items.forEach((itemData) => {
            ddbStaffMappingList.push(itemData);
        });

        if (data.LastEvaluatedKey) {
            getStaffListParams.ExclusiveStartKey = data.LastEvaluatedKey;
            await onQueryStaffmappingTL(); // Continue querying
        }
        // No explicit return needed here, as the caller (queryStaffMappingTL) handles the next step
    }

    async function queryStaffMappingTLForMgrId() {
        const queryParams = {
            TableName: "STF_MAPPING",
            IndexName: "MGR_ID-index",
            KeyConditionExpression: "MGR_ID = :stfId",
            ExpressionAttributeValues: {
                ":stfId": staffId,
            },
            ProjectionExpression: "STF_ID",
        };

        let lastEvaluatedKey;
        do {
            if (lastEvaluatedKey) {
                queryParams.ExclusiveStartKey = lastEvaluatedKey;
            }
            const data = await myDocumentClient.send(new QueryCommand(queryParams));
            data.Items.forEach((itemData) => {
                ddbStaffMappingList.push(itemData);
            });
            lastEvaluatedKey = data.LastEvaluatedKey;
        } while (lastEvaluatedKey);

        const eventQueryAppDetails = setStaffMappingParams();
        console.log("eventQueryAppDetails:", eventQueryAppDetails);
        return await callQueryAppDetailsLambda(eventQueryAppDetails); // Return here
    }

    // for CM
    async function queryStaffMappingCM() {
        getStaffListParams = { // Re-assign within scope
            TableName: "STF_MAPPING",
            FilterExpression: "CHANNEL_ID = :channelId AND (#STAFF_ROLE = :roleTM OR #STAFF_ROLE = :roleTL)",
            ExpressionAttributeNames: {
                "#STAFF_ROLE": "ROLE",
            },
            ExpressionAttributeValues: {
                ":channelId": channelId,
                ":roleTM": "TM",
                ":roleTL": "TL",
            },
            ProjectionExpression: "STF_ID, MGR_ID",
        };

        await onScanStaffmappingCM(); // Populates ddbStaffMappingList
        // After scan, perform the reduce and then call lambda
        ddbStaffMappingList = ddbStaffMappingList.reduce((r, a) => {
            const { MGR_ID, STF_ID } = a;
            if (!r[MGR_ID]) {
                r[MGR_ID] = [];
            }
            r[MGR_ID].push({ STF_ID });
            return r;
        }, {});

        const eventQueryAppDetails = setStaffMappingParams();
        return await callQueryAppDetailsLambda(eventQueryAppDetails); // Return here
    }

    async function onScanStaffmappingCM() {
        const data = await myDocumentClient.send(new ScanCommand(getStaffListParams));

        data.Items.forEach((itemData) => {
            ddbStaffMappingList.push(itemData);
        });

        if (data.LastEvaluatedKey) {
            getStaffListParams.ExclusiveStartKey = data.LastEvaluatedKey;
            await onScanStaffmappingCM();
        }
    }

    // for PU
    async function scanStaffMappingPU() {
        getStaffListParams = { // Re-assign within scope
            TableName: "CHNL_MAPPING",
            ProjectionExpression: "CHANNEL_ID",
        };

        await onScanStaffmapping(); // Populates ddbStaffMappingList
        const eventQueryAppDetails = setStaffMappingParams();
        return await callQueryAppDetailsLambda(eventQueryAppDetails); // Return here
    }

    async function onScanStaffmapping() {
        const data = await myDocumentClient.send(new ScanCommand(getStaffListParams));

        data.Items.forEach((itemData) => {
            // Note: Your original code had '||' which would be true if CHANNEL_ID is undefined.
            // Changed to '&&' to ensure it's not undefined AND not empty.
            if (itemData.CHANNEL_ID !== undefined && itemData.CHANNEL_ID !== "") {
                if (tempChannelIds.indexOf(itemData.CHANNEL_ID) === -1) {
                    tempChannelIds.push(itemData.CHANNEL_ID);
                    ddbStaffMappingList.push(itemData);
                }
            }
        });

        if (data.LastEvaluatedKey) {
            getStaffListParams.ExclusiveStartKey = data.LastEvaluatedKey;
            await onScanStaffmapping();
        }
    }

    function setStaffMappingParams() {
        return {
            ddbStaffMappingList: ddbStaffMappingList,
            staffId: staffId,
            dateString: dateString,
            channelId: channelId,
            role: role,
            startDate: startDate,
            endDate: endDate,
        };
    }

    async function callQueryAppDetailsLambda(eventQueryAppDetails) {
        console.log("inside callQueryAppDetailstambda");
        const tmParams = {
            FunctionName: "QueryAppDetailsLMS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(eventQueryAppDetails),
        };

        console.log("eventQueryAppDetails for QueryAppDetailsLMS:", eventQueryAppDetails);
        try {
            const data = await lambda.send(new InvokeCommand(tmParams));
            console.log("QueryAppDetailsLMS no error observed");
            const responseBody = { // Declare as const
                respType: "001",
                response: "Success",
                role: role,
                appData: JSON.parse(Buffer.from(data.Payload).toString()),
            };
            return setResponseFinal(responseBody);
        } catch (err) {
            console.error("QueryAppDetailsLMS encountered error", err);
            return onError(err);
        }
    }

    function onError(err) {
        console.error("Error encountered:", err);
        const responseFail = {
            statusCode: 500,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Cache-Control",
                "Cache-Control": "no-cache, no-store, must-revalidate",
            },
            body: JSON.stringify({ message: "Internal Server Error", error: err.message }),
            isBase64Encoded: false,
        };
        return responseFail;
    }

    function setResponseFinal(responseBody) {
        console.log("inside setResponseFinal");
        const responseParam = {
            statusCode: 200,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Cache-Control",
                "Cache-Control": "no-cache, no-store, must-revalidate",
            },
            body: JSON.stringify(responseBody),
            isBase64Encoded: false,
        };
        return responseParam;
    }
};
