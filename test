import { LambdaClient, InvokeCommand } from "@aws-sdk/client-lambda";
import { DynamoDBDocumentClient, QueryCommand, ScanCommand } from "@aws-sdk/lib-dynamodb";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

const lambda = new LambdaClient({});
const dbClient = new DynamoDBClient({});
const myDocumentClient = DynamoDBDocumentClient.from(dbClient);

export const handler = async (event, context) => {
    let responseBody = null;
    let responseFinal = null;

    try {
        const eventNew = JSON.parse(event.body);
        let { staffId, key } = eventNew;

        let role = null;
        let channelId = null;
        let ddbStaffMappingList = [];

        // Validate event body and key
        if (!event.body || key === undefined) {
            responseBody = {
                respType: "000",
                response: "Invalid request: Missing event body or key.",
            };
            return setResponseFinal(responseBody);
        }

        // Get Staff Details from Lambda
        const paramsStaff = {
            FunctionName: "getStaffDetailsLMS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(staffId),
        };

        const lambdaResponse = await lambda.send(new InvokeCommand(paramsStaff));
        const dataItems = JSON.parse(Buffer.from(lambdaResponse.Payload).toString());
        const resp = JSON.parse(dataItems.body);

        if (!resp.response || !resp.response.isExist) {
            responseBody = {
                respType: "000",
                response: "Agent does not exist. Please add agent before proceeding",
            };
            return setResponseFinal(responseBody);
        }

        role = resp.response.role;
        staffId = resp.response.stfId;
        channelId = resp.response.channelId;
        const rangeDate = new Date(new Date().setDate(new Date().getDate() - 90));
        const dateString = rangeDate.toISOString();

        // Determine search based on role
        if (role === "TM") {
            ddbStaffMappingList = [{ STF_ID: staffId }];
        } else if (role === "TL") {
            let lastEvaluatedKey;
            do {
                const getStaffList = {
                    TableName: "STF_MAPPING",
                    IndexName: "MGR_ID-index",
                    KeyConditionExpression: "#MGR_ID = :staffId",
                    ExpressionAttributeNames: { "#MGR_ID": "MGR_ID" },
                    ExpressionAttributeValues: { ":staffId": staffId },
                    ProjectionExpression: "STF_ID",
                    ExclusiveStartKey: lastEvaluatedKey,
                };
                const data = await myDocumentClient.send(new QueryCommand(getStaffList));
                data.Items.forEach(itemData => ddbStaffMappingList.push(itemData));
                lastEvaluatedKey = data.LastEvaluatedKey;
            } while (lastEvaluatedKey);
            ddbStaffMappingList.push({ STF_ID: staffId }); // Include the TL themselves
        } else if (role === "CM") {
            let lastEvaluatedKey;
            do {
                const getStaffList = {
                    TableName: "STF_MAPPING",
                    IndexName: "CHANNEL_ID-index",
                    KeyConditionExpression: "CHANNEL_ID = :channelId",
                    FilterExpression: "#Staff_Role = :TM OR #Staff_Role = :TL",
                    ExpressionAttributeNames: { "#Staff_Role": "ROLE" },
                    ExpressionAttributeValues: {
                        ":channelId": channelId,
                        ":TM": "TM",
                        ":TL": "TL",
                    },
                    ProjectionExpression: "STF_ID",
                    ExclusiveStartKey: lastEvaluatedKey,
                };
                const data = await myDocumentClient.send(new QueryCommand(getStaffList));
                data.Items.forEach(itemData => ddbStaffMappingList.push(itemData));
                lastEvaluatedKey = data.LastEvaluatedKey;
            } while (lastEvaluatedKey);
        } else if (role === "PU") {
            let lastEvaluatedKey;
            do {
                const getStaffList = {
                    TableName: "CHNL_MAPPING",
                    ProjectionExpression: "CHANNEL_ID",
                    ExclusiveStartKey: lastEvaluatedKey,
                };
                const data = await myDocumentClient.send(new ScanCommand(getStaffList));
                data.Items.forEach(itemData => ddbStaffMappingList.push(itemData));
                lastEvaluatedKey = data.LastEvaluatedKey;
            } while (lastEvaluatedKey);
        } else {
            responseBody = {
                respType: "000",
                response: "Role is not authorized to perform any action.",
            };
            return setResponseFinal(responseBody);
        }

        // Call SearchAppDetailsLambdaLMS Lambda
        const eventQueryAppDetails = {
            ddbStaffMappingList: ddbStaffMappingList,
            staffId: staffId,
            dateString: dateString,
            channelId: channelId,
            role: role,
            searchKey: key,
        };

        const searchParams = {
            FunctionName: "SearchAppDetailsLambdaLMS",
            InvocationType: "RequestResponse",
            LogType: "Tail",
            Payload: JSON.stringify(eventQueryAppDetails),
        };

        const searchLambdaResponse = await lambda.send(new InvokeCommand(searchParams));
        const appData = JSON.parse(Buffer.from(searchLambdaResponse.Payload).toString());

        responseBody = {
            respType: "001",
            response: "Success",
            role: role,
            appData: appData,
        };
        responseFinal = setResponseFinal(responseBody);
        return responseFinal;

    } catch (err) {
        console.error("Error:", err);
        return {
            statusCode: 500,
            headers: { "Access-Control-Allow-Origin": "*" },
            body: JSON.stringify({ message: "An internal server error occurred.", error: err.message }),
            isBase64Encoded: false,
        };
    }
};

// Common function for setting final response format
function setResponseFinal(responseBody) {
    return {
        statusCode: 200,
        headers: { "Access-Control-Allow-Origin": "*" },
        body: JSON.stringify(responseBody),
        isBase64Encoded: false,
    };
}
