const https = require("https"); // Still used for basic HTTPS requests if not replaced by a library
const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, QueryCommand, UpdateCommand } = require("@aws-sdk/lib-dynamodb"); // For simplified DynamoDB operations

const customHttpsRequest = require("./httpsRequest");
const databaseClient = require("./databaseServices"); // This module needs to be updated for SDK v3 as well
const s3Service = require("./retrieveDocuments"); // This module needs to be updated for SDK v3
const savePdfS3Service = require("./uploadPdfDoc"); // This module needs to be updated for SDK v3
const docUplod = require("./docUpload");

// Initialize DynamoDB Document Client for SDK v3
const ddbClient = new DynamoDBClient({ region: process.env.AWS_REGION || "eu-west-1" }); // Use AWS_REGION environment variable
const ddb = DynamoDBDocumentClient.from(ddbClient);

/**
 * Pass the data to send as 'event.data, and the request options as
 * event.options.
 * For more information see the HTTPS module documentation
 * at https://nodejs.org/api/https.html.
 * Will succeed with the response body.
 */

exports.handler = async (event, context, callback) => {
  console.log("event", JSON.stringify(event));

  // Ensure event.body is parsed if it's a string
  let requestBody;
  try {
    requestBody = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
  } catch (parseError) {
    console.error("Error parsing event.body:", parseError);
    return errorResponse("Invalid request body format", context.awsRequestId, callback);
  }

  console.log("request", requestBody);
  console.log("request object is", JSON.stringify(requestBody));

  let appId = requestBody.appId;
  console.log("APP ID before", appId);

  let host = process.env.CREATE_AND_UPLOAD_API_HOST;
  console.log(host);

  let methodType = "POST";

  try {
    const userdata = await scanAppTable(appId);
    console.log("APP ID", appId);
    console.log("userdata", userdata);

    if (userdata.Items && userdata.Items.length >= 1) {
      console.log("inside if userdata");

      let additionalData = userdata.Items[0].ADDITIONAL_DATA;
      let apeId = userdata.Items[0].APE_ID;

      // Ensure additionalData is a parsed object
      let parsedAdditionalData;
      try {
        parsedAdditionalData = typeof additionalData === 'string' ? JSON.parse(additionalData) : additionalData;
      } catch (e) {
        console.error("Error parsing additionalData:", e);
        return errorResponse("Error parsing additional data", context.awsRequestId, callback);
      }

      let fileObj = await s3Service.getDocumentRecords(appId); // This call needs to be updated for SDK v3
      let pdfRequestData = { ...parsedAdditionalData, ...fileObj };
      let createPDFApi = process.env.CREATE_AND_UPLOAD_CRAETEPDF_API_PATH;

      console.log("Your request for PDF", pdfRequestData);

      let pdfHeaders = {
        "Content-Type": "application/json",
        "x-hsbc-client-id": process.env.CLIENT_ID,
        "x-hsbc-client-secret": process.env.CLIENT_SECRET,
      };

      console.log("creating pdf request");
      console.log(JSON.stringify(pdfRequestData));
      console.log({
        host,
        createPDFApi,
        pdfHeaders,
        methodType,
        req: JSON.stringify(pdfRequestData),
      });

      const pdfApiResponse = await customHttpsRequest.createHttpsRequestPromise(
        host,
        createPDFApi,
        pdfHeaders,
        methodType,
        JSON.stringify(pdfRequestData)
      );

      if (pdfApiResponse.data !== undefined && pdfApiResponse.data) {
        console.log("started saving Credit Card Application Form");
        let obj = {
          appId: pdfApiResponse.appid,
          docName: "CreditCardApplicationForm",
          fileData: pdfApiResponse.data,
          fileName: pdfApiResponse.fileName,
          fileType: pdfApiResponse.fileType,
        };

        console.log("Request Obj", obj);
        await savePdfS3Service.uploadFormPDF(obj); // This call needs to be updated for SDK v3
        console.log("Save complete for Credit Card Application Form ");

        let fullAppPdf = {
          docType: pdfApiResponse.fileType,
          fileName: pdfApiResponse.fileName,
          docName: "CreditCardApplicationForm",
          imagePreviewUrl: pdfApiResponse.data,
        };

        let fileNetRequest = {
          appDetails: additionalData, // Keep as string for docUploadRecords
          apeId: apeId,
          fileObj: fullAppPdf,
        };

        let docUploadRequest = docUplod.docUploadRecords(fileNetRequest);
        console.log("fileNetRequest length:", docUploadRequest.length);

        let filenetApi = process.env.CREATE_AND_UPLOAD_UPLOAD_API_PATH;
        let filenetHeaders = {
          "Content-Type": "application/json",
          "x-hsbc-client-id": process.env.CLIENT_ID,
          "x-hsbc-client-secret": process.env.CLIENT_SECRET,
        };

        await customHttpsRequest.createHttpsRequestPromise(
          host,
          filenetApi,
          filenetHeaders,
          methodType,
          docUploadRequest
        );

        console.log("upload success");

        callback(null, {
          statusCode: 200,
          body: JSON.stringify({
            status: "ok",
          }),
          headers: responseHeaders,
        });

        let BACKENDAPI_STATUS = "Successful";
        var paramBackendStatus = {
          TableName: "APP_DETAILS",
          Key: { APP_ID: appId },
          UpdateExpression: "set BACKENDAPI_STATUS = :backendAPIStatus",
          ExpressionAttributeValues: {
            ":backendAPIStatus": BACKENDAPI_STATUS,
          },
          ReturnValues: "ALL_NEW",
        };

        console.log("Updating record for " + appId);
        await databaseClient.updateRecordForApe(paramBackendStatus); // This call needs to be updated for SDK v3
        console.log("dbUpdateResponse: Update complete"); // Logging simplified as updateRecordForApe now handles its own logging

      } else {
        errorResponse(
          "Error in Reading Pdf Api Response: Data is undefined or null",
          context.awsRequestId,
          callback
        );
      }
    } else {
      errorResponse(
        "No user data found for APP ID: " + appId,
        context.awsRequestId,
        callback
      );
    }
  } catch (e) {
    console.error("An error occurred in handler:", e);
    errorResponse(
      JSON.stringify(e.message || e),
      context.awsRequestId,
      callback
    );
  }
};

async function scanAppTable(appId) {
  console.log("scanAppTable ", appId);
  var params = {
    TableName: "APP_DETAILS",
    KeyConditionExpression: "#appId = :appId",
    ExpressionAttributeNames: {
      "#appId": "APP_ID",
    },
    ExpressionAttributeValues: {
      ":appId": appId,
    },
  };
  // Use SDK v3 QueryCommand
  const data = await ddb.send(new QueryCommand(params));
  return data;
}

function errorResponse(errorMessage, awsRequestId, callback) {
  callback(null, {
    statusCode: 500,
    body: JSON.stringify({
      Error: errorMessage,
      Reference: awsRequestId,
    }),
    headers: responseHeaders,
  });
}

const responseHeaders = {
  "Access-Control-Allow-Origin": process.env.CORS_ORIGIN || "*", // Default to * if not set
  "Strict-Transport-Security": "max-age=16070400; includeSubDomains",
  "X-Content-Type-Options": "nosniff",
  // "X-XSS-Protection": "1; mode=block", // Uncomment if needed
  // "Content-Security-Policy": "default-src 'self'", // Uncomment and configure if needed
};
